I"w<h1 id="완전-탐색-이란">완전 탐색 이란?</h1>

<p>컴퓨터의 빠른 계산 능력을 이용하여 가능한 경우의 수를 일일이 나열하면서 답을 찾는 방법을 의미한다. ‘무식하게 푼다’라는 의미인 Brute-Fore, Exhaustive Search라고 한다. 가능한 모든 경우의 수를 다 해보는 것이기에 알고리즘 풀 때 가장 강력하고 확실한 방법이지만 그만큼 시간이 가장 오래 걸리는 탐색 기법이다.</p>

<h1 id="완전-탐색-기법의-종류">완전 탐색 기법의 종류</h1>

<ul>
  <li>Brute Force : for문과 if문을 이용하여 처음부터 끝까지 탐색하는 방법</li>
  <li>비트 마스크 : 이진수 표현을 자료구조로 쓰는 기법(AND, OR, XOR, SHIFT, NOT) , 문제에서 나올 수 있는 모든 경우의 수가 각각의 원소가 포함되거나, 포함되지 않는 두 가지 선택으로 구성되는 경우에 유용하게 사용이 가능</li>
  <li>재귀 함수 : 비트마스크와 마찬가지로 주로 각 원소가 포함되거나, 포함되지 않는 두 가지 선택을 가질 때 이용된다.</li>
  <li>순열 : 완전 탐색의 대표적인 유형. 서로 다른 n개의 원소에서 r개의 중복을 허용하지 않고 순서대로 늘어 놓은 수</li>
  <li>BFS(너비우선탐색), DFS(깊이우선탐색)</li>
</ul>

<p>기본적으로 완전탐색은 N의 크기가 작을 때 이용이 되기 때문에 보통 시간 복잡도가 지수승이나, 팩토리얼 꼴로 나올 때 많이 이용된다.</p>

<h2 id="bfsbreadth-first-search">BFS(Breadth-First Search)</h2>

<p>너비 우선 탐색, 최대한 넓게 이동한 다음, 더 이상 갈 수 없을 때 아래로 이동</p>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc305k7%2FbtqB5E2hI4r%2Fea7vFo08tkDYo4c8wkfVok%2Fimg.gif" /></p>

<p>루트 노드(혹은 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법으로, 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.</p>

<p>주로 두 노드 사이의 최단 경로를 찾고 싶을 때 이 방법을 선택한다.</p>

<h3 id="bfs-trees">BFS-Trees</h3>

<p>큐가 한개 이상의 노드를 가지고 있는 이상 아래 방법을 반복한다.</p>

<ul>
  <li>큐에서 첫번째 노드를 빼낸다.</li>
  <li>만약 그 노드가 우리가 찾던 그 노드라면, 검색은 종료된다.</li>
  <li>아니면 그 노드의 자식을 큐 마지막에 삽입하고 위의 방법을 반복 한다.</li>
</ul>

<h3 id="bfs-gaphs">BFS-Gaphs</h3>

<p>그래프인 경우에는 방문한 노드의 collection을 유지해야하고 두번 방문하지 않도록 해야 한다.  그렇지 않으면 무한 루프에 빠지게 될 수 있다.</p>

<ul>
  <li>큐에서 첫번째 노드를 빼낸다.</li>
  <li>노드에 방문했는지 확인한다, 방문 했으면 스킵한다.</li>
  <li>만약 그 노드가 우리가 찾던 그 노드라면, 검색은 종료된다.</li>
  <li>아니면 그 노드를 방문한 노드들에 추가한다.</li>
  <li>아니면 그 노드의 자식을 큐 마지막에 삽입하고 위의 방법을 반복 한다.</li>
</ul>

<h3 id="자바-코드">자바 코드</h3>

<h3 id="trees">Trees</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tree</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
		<span class="kd">private</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Tree</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="n">children</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">Tree</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">children</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Tree</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">of</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Tree</span><span class="o">&lt;&gt;(</span><span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Tree</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">addChild</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Tree</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">newChild</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Tree</span><span class="o">&lt;&gt;(</span><span class="n">value</span><span class="o">);</span>
        <span class="n">children</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">newChild</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">newChild</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>싸이클을 만드는 걸 피하기 위해, 자식노드들은 주어진 값을 바탕으로 클래스에 의해 작성 되어야 한다. search(0 메소드를 만들어 보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Tree</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="nf">search</span><span class="o">(</span><span class="no">T</span> <span class="nc">Value</span><span class="o">,</span> <span class="nc">Tree</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">root</span><span class="o">){</span>
			<span class="c1">//...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위에서 언급했듯이, BFS는 노드를 순회하기 위해 큐를 사용한다. 우선, root 노드를 큐에 추가해야 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Tree</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
<span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
</code></pre></div></div>

<p>그리고 큐가 비어있지 않는동안 반복해야하고 매번 큐에서 노드를 빼낸다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
		<span class="nc">Tree</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">currentNode</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>만약 그 노드가 우리가 찾고 있는 것이라면 return 하고 아니면 자식 노드를 큐에 추가 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(</span><span class="n">currentNode</span><span class="o">.</span><span class="na">getValue</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">value</span><span class="o">))</span> <span class="o">{</span>
		<span class="k">return</span> <span class="nc">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">currentNode</span><span class="o">);</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
		<span class="n">queue</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">currentNode</span><span class="o">.</span><span class="na">getChildren</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<p>마지막으로, 우리가 찾고자 하는 것을 찾지 못하고 모든 노드를 방문 했다면 empty 결과를 반환한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="nc">Optional</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
</code></pre></div></div>

<p>아래는 예제이다.</p>

<p><img src="https://www.baeldung.com/wp-content/uploads/2019/10/BFS-Tree-Example.png" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Tree</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">root</span> <span class="o">=</span> <span class="nc">Tree</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
<span class="nc">Tree</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">rootFirstChild</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">addChile</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
<span class="nc">Tree</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">depthMostChild</span> <span class="o">=</span> <span class="n">rootFirstChild</span><span class="o">.</span><span class="na">addChild</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
<span class="nc">Tree</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">rootSecondChild</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">addChild</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
</code></pre></div></div>

<p>Value값 4를 찾는다고 할때, 10 → 2→ 4 순서로 순회할 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BreadthFirstSearchAlgorithm</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">root</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c</span><span class="o">.</span><span class="na">b</span><span class="o">.</span><span class="na">a</span><span class="o">.</span><span class="na">b</span><span class="o">.</span><span class="na">BreadthFirstSearchAlgorithm</span> <span class="o">-</span> <span class="nc">Visited</span> <span class="n">node</span> <span class="n">with</span> <span class="nl">value:</span> <span class="mi">10</span>
<span class="n">c</span><span class="o">.</span><span class="na">b</span><span class="o">.</span><span class="na">a</span><span class="o">.</span><span class="na">b</span><span class="o">.</span><span class="na">BreadthFirstSearchAlgorithm</span> <span class="o">-</span> <span class="nc">Visited</span> <span class="n">node</span> <span class="n">with</span> <span class="nl">value:</span> <span class="mi">2</span> 
<span class="n">c</span><span class="o">.</span><span class="na">b</span><span class="o">.</span><span class="na">a</span><span class="o">.</span><span class="na">b</span><span class="o">.</span><span class="na">BreadthFirstSearchAlgorithm</span> <span class="o">-</span> <span class="nc">Visited</span> <span class="n">node</span> <span class="n">with</span> <span class="nl">value:</span> <span class="mi">4</span>
</code></pre></div></div>

<h2 id="dfsdepth-first-search">DFS(Depth-First Search)</h2>

<p>깊이 우선 탐색, 최대한 깊이 내려 간 뒤, 더이상 깊이 갈 곳이 없을 경우 옆으로 이동</p>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FxC9Vq%2FbtqB8n5A25K%2FGyOf4iwqu8euOyhwtFuyj1%2Fimg.gif" /></p>

<p>루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어 가기 전에 해당 분기를 완벽하게 탐색하는 방식이다.</p>

<ol>
  <li>모든 노드를 방문하고자 하는 경우에 이 방법 선택</li>
  <li>DFS가 BFS보다 좀더 간단</li>
</ol>

<h2 id="tree-dfs">Tree DFS</h2>

<ul>
  <li>전위 순회 (Pre-Order Traversal) : root → left → right</li>
  <li>중위 순회 (Inorder Traversal) : left → root → right</li>
  <li>후위 순회 (Post-Order Traversal) : left → right → root</li>
</ul>

<h3 id="전위-순회-pre-order-traversal">전위 순회 Pre-Order Traversal</h3>

<p>root → left → right</p>

<p>재귀를 사용해서 전위 순회를 수행할 수 있다.</p>

<ul>
  <li>현재 노드를 방문한다</li>
  <li>왼쪽 하위노드를 순회한다</li>
  <li>오른쪽 하위 노드를 순회한다</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">traversePreOrder</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">visit</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
        <span class="n">traversePreOrder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="n">traversePreOrder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>재귀 없이 전위 순회를 수행할 수 도 있다.</p>

<p>반복적인 전위 순회를 하기 위해, 우리는 스택이 필요하다.</p>

<ul>
  <li>root를 stack에 push 한다</li>
  <li>stack이 empty가 아닌동안
    <ul>
      <li>현재 노드를 pop</li>
      <li>현재 노드를 방문</li>
      <li>오른쪽 자식노드를 push 그리고 왼쪽 자식 노드를 stack으로</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">traversePreOrderWithoutRecursion</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;();</span>
    <span class="nc">Node</span> <span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
    <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="k">while</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="n">visit</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
        
        <span class="k">if</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>    
        <span class="k">if</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>        
<span class="o">}</span>
</code></pre></div></div>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/a/ac/Preorder-traversal.gif" /></p>

<h3 id="중위-순회-inorder-traversal">중위 순회 InOrder Traversal</h3>

<p>left → root → right</p>

<p>이진 탐색 트리에서 중위 순회는 그들의 값을 기준으로 오름차순으로 순회 하는것을 의미한다</p>

<p>재귀와 함께</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">traverseInOrder</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">traverseInOrder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="n">visit</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
        <span class="n">traverseInOrder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>재귀 없이</p>

<ul>
  <li>root를 stack에 push</li>
  <li>stack이 empty가 아닌 동안
    <ul>
      <li>현재 노드의 가장 왼쪽 자식 노드 까지 닿을 때 까지 왼쪽 자식을 스택으로 push 한다</li>
      <li>현재 노드를 방문하다</li>
      <li>오른쪽 자식을 stack으로 push 한다</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">traverseInOrderWithoutRecursion</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;();</span>
    <span class="nc">Node</span> <span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
    <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="k">while</span><span class="o">(!</span> <span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>                
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>                
        <span class="o">}</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="n">visit</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>                
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>후위 순회 PostOrder Traversal</p>

<p>재회와 함께</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">traversePostOrder</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">traversePostOrder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="n">traversePostOrder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="n">visit</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>재회 없이</p>

<ul>
  <li>root 노드를 stack에 push</li>
  <li>stack이 empty가 아닌 동안
    <ul>
      <li>왼쪽과 오른쪽을 이미 방문 했는지 확인한다</li>
      <li>아니라면 오른쪽과 왼쪽을 stack으로 push</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">traversePostOrderWithoutRecursion</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;();</span>
    <span class="nc">Node</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
    <span class="nc">Node</span> <span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
    <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

    <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
        <span class="kt">boolean</span> <span class="n">hasChild</span> <span class="o">=</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">current</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">isPrevLastChild</span> <span class="o">=</span> <span class="o">(</span><span class="n">prev</span> <span class="o">==</span> <span class="n">current</span><span class="o">.</span><span class="na">right</span> <span class="o">||</span> 
          <span class="o">(</span><span class="n">prev</span> <span class="o">==</span> <span class="n">current</span><span class="o">.</span><span class="na">left</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">));</span>

        <span class="k">if</span> <span class="o">(!</span><span class="n">hasChild</span> <span class="o">||</span> <span class="n">isPrevLastChild</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="n">visit</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>   
<span class="o">}</span>
</code></pre></div></div>

<h2 id="dfs-vs-bfs">DFS vs BFS</h2>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcQYkI8%2FbtqB8oDsMGe%2FEEYm0cKGYhxTR0kJhGiJPK%2Fimg.gif" /></p>

<table>
  <thead>
    <tr>
      <th>DFS</th>
      <th>BFS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>현재 정점에서 갈 수 있는 점들까지 들어가면서 탐색</td>
      <td>현재 정점에서 연결된 가까운 점들부터 탐색</td>
    </tr>
    <tr>
      <td>스택 또는 재귀 함수로 구현</td>
      <td>큐를 이용해서 구현</td>
    </tr>
  </tbody>
</table>

<h2 id="시간-복잡도">시간 복잡도</h2>

<p>N은 노드, E는 간선일 때</p>

<blockquote>
  <p>인접 리스트 : O(N+E)인접 행렬 : O(N²)</p>
</blockquote>

<p>출처 : <a href="https://www.baeldung.com/java-breadth-first-search">https://www.baeldung.com/java-breadth-first-search</a>
<a href="https://upload.wikimedia.org/wikipedia/commons/a/ac/Preorder-traversal.gif">https://upload.wikimedia.org/wikipedia/commons/a/ac/Preorder-traversal.gif</a></p>
:ET