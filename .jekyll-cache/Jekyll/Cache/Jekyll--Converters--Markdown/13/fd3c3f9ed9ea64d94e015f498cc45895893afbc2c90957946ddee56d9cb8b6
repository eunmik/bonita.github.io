I"k<h2 id="8-익명사용자-인증-필터--anonymousauthenticationfilter">8. 익명사용자 인증 필터 : AnonymousAuthenticationFilter</h2>

<p>어떤 사용자가 인증을 받으면 session에 user객체가 저장 되고</p>

<p>이 사용자가 어떤 자원에 접근하려고 하면 session에서 user객체가 존재하는지 확인한다.</p>

<p>user객체가 null이면 이 사용자는 인증을 받지 않았다고 판단 해서</p>

<p>그 자원에 접근하지 못하게 만들고</p>

<p>null이 아니면 인증을 받았다고 판단하고 자원에 접근하도록 처리 한다.</p>

<p>이렇게 인증된 사용자와 인증받지 않은 사용자를 구분하여 처리 한다.</p>

<p>AnonymousAuthenticationFilter는</p>

<p>인증을 받지 않은 사용자는 null로 처리하는게 아니라 별도의 Anonymous 객체를 생성하여 처리한다.</p>

<p><img src="https://eunmik.github.io/bonita.github.io/assets/img/210614-img1.JPG" /></p>

<ol>
  <li>사용자가 요청을 하면 AnonymoiusAuthenticationFilter가 요청을 받는다.</li>
  <li>현재 요청하고 있는 사용자가 인증객체가 있는지 없는지 부터 판단
    <ul>
      <li>인증객체는 인증에 최종적으로 성공하게 되면 SecurityContext안에 저장이 되어있는데</li>
      <li>인증객체가 존재하게 되면 다른 Filter에서 처리하도록 넘어간다.</li>
    </ul>
  </li>
  <li>인증객체가 존재하지 않는다면  AnonymousAuthenticationToken을 생성한다.</li>
  <li>SecurityContext 객체 안에 익명사용자용 토큰 객체를 저장한다.
    <ul>
      <li>인명사용자라고 할지라도 인증사용자처럼 동일하게 SecurityContext안에 인증객체를 저장</li>
    </ul>
  </li>
</ol>

<p>SecurityContext는 isAnonymous()를 검사를 할때 SecurityContext안에 객체를 검사해서 판단한다.</p>

<p>AnonymousAuthenticationFilter는 인증사용자와 익명사용자를 구분하기 위해 사용되는 Filter이다.</p>

<p>isAnonymous()가 true일 때 로그인 메뉴를 보이게 하고</p>

<p>isAuthenticated()가 true일 때 로그아웃 메뉴를 보이게 하도록 구성할 수 있다</p>

<p>인증객체를 가지고 있는 익명 사용자이지만 실제로 인증을 받지않은 사용자이기 때문에 세션에 저장할 필요가 없다.</p>

<h2 id="9-동시-세션-제어-세션-고정-보호-세션-정책">9. 동시 세션 제어, 세션 고정 보호, 세션 정책</h2>

<h3 id="동시-세션-제어">동시 세션 제어</h3>

<p>현재 동일한 계정으로 인증을 받을 때 그 세션에 혀용 갯수가 초과 되었을 때</p>

<p>어떻게 그 세션을 계속적으로 초과하지 않고 캐시를 유지않고 사용할 수 있는 지 알아보자.</p>

<p>Spring Security는 두가지 전략으로 동접을 제어하고 있다.</p>

<p><img src="https://eunmik.github.io/bonita.github.io/assets/img/210614-img2.JPG" /></p>

<p>최대 세션 허용 개수를 초과할 경우</p>

<ol>
  <li>이전 사용자 세션 만료 시키는 전략  (허용갯수가 1일 때)
    <ul>
      <li>사용자 1이 로그인을 하면 서버에서 인증성공을 하고 사용자1의 세션이 생성</li>
      <li>서버에는 사용자 1의 세션이 생성이 되어있다.</li>
      <li>사용자 2가 동일한 계정으로 로그인을 한다. 사용자2의 세션이 생성.</li>
      <li>사용자2가 로그인을 해서 세션을 생성할 때 이전 사용자 세션을 만료 시키는 설정을 한다.</li>
      <li>사용자1의 세션은 만료, 사용자 2의 세션은 유효</li>
    </ul>
  </li>
  <li>현재 사용자 인증 실패 시키는 전략 (허용갯수가 1일 때)
    <ul>
      <li>사용자 1이 로그인을 하면서 인증 성공 후 세션 생성</li>
      <li>사용자 2가 동일 한 계정으로 로그인 하면 인증에 실패함으로서 세션 생성 실패</li>
      <li>사용자 2의 로그인을 차단하는 전략</li>
    </ul>
  </li>
</ol>

<p><img src="https://eunmik.github.io/bonita.github.io/assets/img/210614-img3.JPG" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">http</span>
<span class="o">.</span><span class="na">sessionManagement</span><span class="o">()</span>
<span class="o">.</span><span class="na">maximumSessions</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">//동시 세션 최대 허용 개수</span>
<span class="o">.</span><span class="na">maxSessionsPreventsLogin</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span> <span class="c1">// true일 경우 현재 사용자가 로그인을 못하게 만든다, default는 false</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>maxSessionPreventsLogin이 false일 경우에</p>

<p>다른 계정에서 로그인하면 전 계정은 아래와 같은 에러 메시지가 발생한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>This session has been expired (possibly due to multiple concurrent logins being attempted as the same user).
</pre></td></tr></tbody></table></code></pre></div></div>

<p>maxSessionPreventsLogin이 true일 경우에</p>

<p>다른 게정을 로그인 하면 현재 계정에서 아래와 같은 에러 메시지가 발생한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>exception : Maximum sessions of 1 for this principal exceeded
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="세션-고정-보호">세션 고정 보호</h3>

<p><img src="https://eunmik.github.io/bonita.github.io/assets/img/210614-img4.JPG" /></p>

<p>세션 고정 공격</p>

<ol>
  <li>공격자가 서버에 공격을 한다 .</li>
  <li>서버는 JSESSIONID를 발급한다.</li>
  <li>공격자는 발급받은 세션 쿠키를 사용자에게 심어 놓는다.</li>
  <li>사용자는 공격자의 세션 쿠키로 로그인을 시도 한다.</li>
  <li>사용자는 인증에 성공 한다.</li>
  <li>
    <p>사용자와 공격자가 동시에 같은 세션 쿠키를 공유하게 되기 때문에</p>

    <p>공격자는 인증 받지 않아도 인증 받은 것처럼 자원에 접근하게 된다.</p>
  </li>
</ol>

<p>사용자가 공격자가 심은 쿠키로 접속하더라도 인증 할 때마다 새로운 세션/쿠키가 생성된다.</p>

<p><img src="https://eunmik.github.io/bonita.github.io/assets/img/210614-img5.JPG" /></p>

<p>changeSessionId() : 기본값, 세션 ID만 변경이 된다.  서블렛 3.1 이상</p>

<p>migrateSession() : 새로운 세션 ID가 발급된다.  이전의 속성 값들을 그대로 사용한다. 서블렛 3.1 이하 에서 기본 값</p>

<p>newSession() : 새로운 세션 ID가 발급 되면서 새로운 값들의 속성을 설정한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="n">http</span>
<span class="o">.</span><span class="na">sessionManagement</span><span class="o">()</span>
<span class="o">.</span><span class="na">sessionFixation</span><span class="o">().</span><span class="na">changeSessionId</span><span class="o">();</span> <span class="c1">//none : 무방비 상태, changeSessionId() : default</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="세션-정책">세션 정책</h3>

<p><img src="https://eunmik.github.io/bonita.github.io/assets/img/210614-img6.JPG" /></p>

<p>JWT 가 Stateless 방식 이다.</p>

<h2 id="10-세션-제어-필터--sessionmanagementfilter-concurrentsessionfilter">10. 세션 제어 필터 : SessionManagementFilter, ConcurrentSessionFilter</h2>

<p><img src="https://eunmik.github.io/bonita.github.io/assets/img/210614-img7.JPG" /></p>

<p>앞의 배웠던 4가지의 핵심적인 기능을 SessionManagementFilter가 하고 있다.</p>

<p><img src="https://eunmik.github.io/bonita.github.io/assets/img/210614-img8.JPG" /></p>

<p>SessionManagementFilter와 마찬가지로 ConcurrentSessionFilter도 동시적 세션 제어를 하고 있다.</p>

<p>이 필터는 매 요청마다 현재 상요자의 세션 만료 여부를 체크 한다.</p>

<p>세션이 만료되었을 경우 즉시 만료 처리 시켜 버린다.</p>

<p><img src="https://eunmik.github.io/bonita.github.io/assets/img/210614-img9.JPG" /></p>

<ol>
  <li>사용자가 로그인을 시도 한다.</li>
  <li>다른 사용자가 동일한 계정으로 세션을 생성한 상태이다.</li>
  <li>최대 세션 허용 개수가 1개일 경우에 세션 허용 개수가 초과가 되었다.</li>
  <li>이천 사용자 세션을 만료하다.</li>
  <li>이전 사용자가 서버에 요청을 할때 마다 ConcurrentSessionFilter가 사용자의 세션 만료 여부를 체크 한다.</li>
  <li>확인할 때 SessionManagementFilter에서 이전 사용자 세션을 만료 했던 그 설정을 참조한다.</li>
  <li>즉시 그 사용자 세션을 만료하고 오류 페이지를 응답한다.</li>
</ol>

<p><img src="https://eunmik.github.io/bonita.github.io/assets/img/210614-img10.JPG" /></p>

<p>조건 : 최대 세션 허용 개수가 1</p>

<ol>
  <li>사용자 1이 로그인을 하면 가장 먼저 ConcurrentSessionControl AuthenticationStrategy를 호출한다.
    <ul>
      <li>동시적 세션 제어를 처리하는 클래스</li>
      <li>인증을 시도하고 있는 사용자가 가지고 있는 계정에 생성된 세션이 count가 얼마인지를 확인한다.</li>
      <li>현재는 사용자 1이 처음으로 세션 생성을 요청했기 때문에 count는 0이다.</li>
    </ul>
  </li>
  <li>그 다음에 ChangedSessionId AuthenticationStrategy를 호출한다.
    <ul>
      <li>세션 고정 보호를 처리하는 클래스</li>
      <li>사용자 1의 새롭게 session을 생성하고 새로운 세션 쿠키를 발급한다.</li>
    </ul>
  </li>
  <li>그 다음엔 RegisterSession AuthenticationStrategy를 호출한다.
    <ul>
      <li>사용자의 세션을 등록하고 지정하는 역할을 하는 클래스</li>
      <li>이 클래스가 처리가 되야 사용자 1의 세션 정보가 등록이 된다.</li>
      <li>그러고 세션 count가 1 이 된다.</li>
    </ul>
  </li>
  <li>사용자 2가 동일한 계정으로 인증을 시도 한다.</li>
  <li>ConcurrentSessionControl을 호출하고 동일한 계정으로 생성된 세션이 있고 세션의 count가 1이다.</li>
  <li>2가지 전략으로 처리 한다.
    <ul>
      <li>인증 실패 전략인 경우 : SessionAuthenticationException, 인증 예외를 발생하고 인증 실패를 한다. ChangedSessionId, RegisterSession 클래스를 호출안하고 바로 인증 실패를 리턴한다.</li>
      <li>세션 만료 전략인 경우 : 현재 사용자는 세션 인증에 성공하고 이전 사용자의 세션을 만료 시킨다.</li>
    </ul>
  </li>
  <li>인증에 성공한 전략 다음에 사용자1 과 동일하게 changedSessionId, 세션 고종 보호 클래스를 호출하고</li>
  <li>RegisterSession 클래스를 호출하여 세션 정보를 등록한다. 그래서 총 세션 count는 두개가 되고 현재 메모리에는 세션 count가 2개가 올라간 상태이다.</li>
  <li>이 때, 사용자 1이 /home이라는 자원에 접근을 요청한다.</li>
  <li>ConcurrentSessionFilter 에서 사용자 1의 만료 여부를 확인하다.</li>
  <li>사용자 2가 사용자1의 세션 만료를 true라고 설정한 부분을 가져 온다.</li>
  <li>사용자 1의 세션의 만료는 true이기 때문에 logout 처리하고 오류 페이지를 응답한다.</li>
</ol>

<h2 id="11-권한-설정과-표현식">11. 권한 설정과 표현식</h2>

<p><img src="https://eunmik.github.io/bonita.github.io/assets/img/210614-img11.JPG" /></p>

<p><img src="https://eunmik.github.io/bonita.github.io/assets/img/210614-img12.JPG" /></p>

<p><img src="https://eunmik.github.io/bonita.github.io/assets/img/210614-img13.JPG" /></p>

<p>Role User 권한을 가지고 있는 사용자가 anonymous() 자원에 접근이 가능한가? NO</p>

<p>SpEL : Spring Expression Language 스프링 표현식</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">configure</span><span class="o">(</span><span class="nc">HttpSecurity</span> <span class="n">http</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">{</span>

        <span class="n">http</span> <span class="c1">//인증정책</span>
                <span class="o">.</span><span class="na">formLogin</span><span class="o">()</span> <span class="c1">//</span>
				<span class="n">http</span>
                    <span class="o">.</span><span class="na">authorizeRequests</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="s">"/user"</span><span class="o">).</span><span class="na">hasRole</span><span class="o">(</span><span class="s">"USER"</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="s">"/admin/pay"</span><span class="o">).</span><span class="na">hasRole</span><span class="o">(</span><span class="s">"ADMIN"</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="s">"/admin/**"</span><span class="o">).</span><span class="na">access</span><span class="o">(</span><span class="s">"hasRole('ADMIN') or hasRole('SYS')"</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">anyRequest</span><span class="o">().</span><span class="na">authenticated</span><span class="o">()</span>
        <span class="o">;</span>

    <span class="o">}</span>

    <span class="c1">//사용자 생성을 위한 오버라이드</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">configure</span><span class="o">(</span><span class="nc">AuthenticationManagerBuilder</span> <span class="n">auth</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">//메모리 방식으로 사용자를 생성, 갯수 제한은 없음</span>
        <span class="n">auth</span><span class="o">.</span><span class="na">inMemoryAuthentication</span><span class="o">().</span><span class="na">withUser</span><span class="o">(</span><span class="s">"user"</span><span class="o">).</span><span class="na">password</span><span class="o">(</span><span class="s">"{noop}1111"</span><span class="o">).</span><span class="na">roles</span><span class="o">(</span><span class="s">"USER"</span><span class="o">);</span> <span class="c1">//noop은 암호화 하지 않은 암호화 유형</span>
        <span class="n">auth</span><span class="o">.</span><span class="na">inMemoryAuthentication</span><span class="o">().</span><span class="na">withUser</span><span class="o">(</span><span class="s">"sys"</span><span class="o">).</span><span class="na">password</span><span class="o">(</span><span class="s">"{noop}1111"</span><span class="o">).</span><span class="na">roles</span><span class="o">(</span><span class="s">"SYS"</span><span class="o">);</span>
        <span class="n">auth</span><span class="o">.</span><span class="na">inMemoryAuthentication</span><span class="o">().</span><span class="na">withUser</span><span class="o">(</span><span class="s">"admin"</span><span class="o">).</span><span class="na">password</span><span class="o">(</span><span class="s">"{noop}1111"</span><span class="o">).</span><span class="na">roles</span><span class="o">(</span><span class="s">"ADMIN"</span><span class="o">);</span>
    <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="12-예외-처리-및-요청-캐시-필터--exceptiontranslationfilter-requestcacheawarefilter">12. 예외 처리 및 요청 캐시 필터 : ExceptionTranslationFilter, RequestCacheAwareFilter</h2>

<p><img src="https://eunmik.github.io/bonita.github.io/assets/img/210614-img14.JPG" /></p>

<p>이 예외는 과연 누가 발생 시키는가? FilterSecurityInterceptorFilter 이다.</p>

<p>Spring Security가 관리하는 보안 필터 중에서 맨 마지막에 위치하고 있다.</p>

<p>이 필터 앞에 위치하는 필터가 ExceptionTranslationFitler이다.</p>

<p>이 필터가 실제로 사용자 요청을 받을 때 그 다음 필터로 그 요청을 전달 해 줄 때</p>

<p>try-catch로 감싸서 이 FilterSecurityInterceptor를 호출하고 있다.</p>

<p>그렇기 때문에 FilterSecurityInterceptor에서 생기는 인증 예외와  인가 예외는 ExceptionTranslationFilter로 throw 하고 있다.</p>

<p><img src="https://eunmik.github.io/bonita.github.io/assets/img/210614-img15.JPG" /></p>

<ol>
  <li>사용자가 /user 자원에 접근을 시도하고 있다.</li>
  <li>인증을 받지 않고 바로 /user 자원에 접근하고 /user는 인증된 사용자만 접근할 수 있을 때</li>
  <li>FilterSecurityInterceptor가 요청을 받고 있고 이 사용자는 인증을 받지 않았다. → 인증을 받지 않고 자원에 접근 했기 때문에 익명 사용자가 접근을 한 것이다.  → 인가 예외가 발생한다.</li>
  <li>ExceptionTranslationFilter가 AccessDeniedException을 발생하지만 익명사용자나 Remember-me로 인증된 사용자 경우에는 AccessDeniedHandler로 가지 않고 AuthenticationException로 가게 된다.</li>
  <li>AuthenticationException안에서 2가지 역할을 처리하는 과정이 있다.
    <ul>
      <li>AuthenticationEntryPoint 인터페이스 구현체를 호출해서 구현체 안에서 /login 페이지로 리다이렉트 한다. 그 전에 Security Context를 null로 만드는 작업을 한다.</li>
      <li>Login 페이지로 redirect 하기 전에 사용자가 요청한 정보를 저장한다. 이 정보는 DefaultSavedRequest 객체안에 저장이 되고 이 객체는 다시 Session에 저장이 되는 역할을HttpSessionRequestCache이 하고 있다.</li>
    </ul>
  </li>
  <li>사용자가 ADMIN 권한이 없는 데 ADMIN 권한이 필요한 /user 자원에 접근할 때</li>
  <li>인가 예외가 발생한다.</li>
  <li>ExceptionTranslationFilter는 인가 예외를 처리한다.</li>
  <li>AccessDeniedException은 AccessDeniedHandler를 호출 한다.</li>
  <li>AccessDeniedHandler는 denied 페이지로 이동한다.</li>
  <li></li>
</ol>

<p><img src="https://eunmik.github.io/bonita.github.io/assets/img/210614-img16.JPG" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="rouge-code"><pre><span class="n">http</span> <span class="c1">//인증정책</span>
                <span class="o">.</span><span class="na">formLogin</span><span class="o">()</span> <span class="c1">//formLogin방식으로 인증을 할 수 있도록 설정</span>
                <span class="o">.</span><span class="na">successHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">AuthenticationSuccessHandler</span><span class="o">()</span> <span class="o">{</span>
                    <span class="nd">@Override</span>
                    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onAuthenticationSuccess</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">httpServletRequest</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">httpServletResponse</span><span class="o">,</span> <span class="nc">Authentication</span> <span class="n">authentication</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ServletException</span> <span class="o">{</span>
                        <span class="nc">RequestCache</span> <span class="n">requestCache</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HttpSessionRequestCache</span><span class="o">();</span> <span class="c1">// 인가/인증 에외가 발생했을 때 로그인 페이지로 가기 전에 요청 정보를 저장하는 것</span>
                        <span class="nc">SavedRequest</span> <span class="n">savedRequest</span> <span class="o">=</span> <span class="n">requestCache</span><span class="o">.</span><span class="na">getRequest</span><span class="o">(</span><span class="n">httpServletRequest</span><span class="o">,</span> <span class="n">httpServletResponse</span><span class="o">);</span> <span class="c1">//이 정보에는 원래 사용자가 가려고 하는 요청정보가 저장되어 있다.</span>
                        <span class="nc">String</span> <span class="n">redirectUrl</span> <span class="o">=</span> <span class="n">savedRequest</span><span class="o">.</span><span class="na">getRedirectUrl</span><span class="o">();</span>
                        <span class="n">httpServletResponse</span><span class="o">.</span><span class="na">sendRedirect</span><span class="o">(</span><span class="n">redirectUrl</span><span class="o">);</span> <span class="c1">//인증에 성공한 다음에 세션에 저장되어있던 url로 이동하도록 처리</span>
                    <span class="o">}</span>
                <span class="o">})</span> <span class="c1">//login에 성공 했을 때 successHandler를 호출, AuthenticationSuccessHandler 인터페이스를 구현한 구현체를 설정하면 된다.</span>
<span class="n">http</span>
                    <span class="o">.</span><span class="na">authorizeRequests</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="s">"/login"</span><span class="o">).</span><span class="na">permitAll</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="s">"/user"</span><span class="o">).</span><span class="na">hasRole</span><span class="o">(</span><span class="s">"USER"</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="s">"/admin/pay"</span><span class="o">).</span><span class="na">hasRole</span><span class="o">(</span><span class="s">"ADMIN"</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="s">"/admin/**"</span><span class="o">).</span><span class="na">access</span><span class="o">(</span><span class="s">"hasRole('ADMIN') or hasRole('SYS')"</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">anyRequest</span><span class="o">().</span><span class="na">authenticated</span><span class="o">()</span>
        <span class="o">;</span>

        <span class="n">http</span>
                    <span class="o">.</span><span class="na">exceptionHandling</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">authenticationEntryPoint</span><span class="o">(</span><span class="k">new</span> <span class="nc">AuthenticationEntryPoint</span><span class="o">()</span> <span class="o">{</span>
                        <span class="nd">@Override</span>
                        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">commence</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">httpServletRequest</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">httpServletResponse</span><span class="o">,</span> <span class="nc">AuthenticationException</span> <span class="n">e</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ServletException</span> <span class="o">{</span>
                            <span class="n">httpServletResponse</span><span class="o">.</span><span class="na">sendRedirect</span><span class="o">(</span><span class="s">"/login"</span><span class="o">);</span>
                        <span class="o">}</span>
                    <span class="o">})</span> <span class="c1">//인증 예외 발생 시</span>
                    <span class="o">.</span><span class="na">accessDeniedHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">AccessDeniedHandler</span><span class="o">()</span> <span class="o">{</span>
                        <span class="nd">@Override</span>
                        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">httpServletRequest</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">httpServletResponse</span><span class="o">,</span> <span class="nc">AccessDeniedException</span> <span class="n">e</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ServletException</span> <span class="o">{</span>
                            <span class="n">httpServletResponse</span><span class="o">.</span><span class="na">sendRedirect</span><span class="o">(</span><span class="s">"/denied"</span><span class="o">);</span>
                        <span class="o">}</span>
                    <span class="o">})</span> <span class="c1">//인가 예외 발생시</span>
        <span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="https://eunmik.github.io/bonita.github.io/assets/img/210614-img17.JPG" /></p>

<h2 id="13-사이트-간-요청-위조---csrf-csrtfilter">13. 사이트 간 요청 위조 - CSRF, CsrtFilter</h2>

<p><img src="https://eunmik.github.io/bonita.github.io/assets/img/210614-img18.JPG" /></p>

<p><img src="https://eunmik.github.io/bonita.github.io/assets/img/210614-img19.JPG" /></p>

<p>서버가 발급한 토큰을 가지고와야지 시큐리티는 발급한 토큰을 검사를 한다.</p>
:ET