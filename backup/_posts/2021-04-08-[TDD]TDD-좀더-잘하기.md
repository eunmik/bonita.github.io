---
layout: post
title: "[TDD] 3장 TDD 좀 더 잘하기"
date: 2021-04-08
excerpt: "TDD 개발을 위한 기본서3"
tags: [Java, TDD]
comments: true
---
## 테스트 케이스 클래스의 위치

### #1. 테스트 대상 소스와 테스트 클래스를 같은 곳에
|    |           | 
|----------|-------------|
| 장점 |  클래스 이름 규칙을 잘 정했을 경우 테스트 클래스를 찾기가 쉽다.  | 
| 단점 |    패키지 내에 제품 코드 클래스와 테스트 클래스가 함께 존재하기 때문에 혼란을 줄 수 있다. 배포 시에 테스트 클래스만 발췌해야 하는 불편함이 있다.   | 
| 선호도 | 아주 낮음. | 



### #2. 테스트 클래스는 하위 패키지로
|    |           | 
|----------|-------------|
| 장점 |  테스트 코드가 가까운 곳에 위치한다.  | 
| 단점 |    이미 하위 패키지가 존재할 경우에는 혼란스러울 수 있다. 테스트 클래스와 제품 클래스를 따로 분리해서 배포하는 데 어려움이 있다.   | 
| 선호도 | 낮음. 지금은 거의 사용되지 않는다.  | 



### #3. 최상위 패키지를 분리
|    |           | 
|----------|-------------|
| 장점 |  업무 코드와 테스트 코드가 섞일 염려가 없다. 테스트 코드만 분리해내기 쉽다.   | 
| 단점 |    default나 protected로 선언된 메소드들에 대해서는 테스트 코드를 작성할 수 없다. 어렵진 않지만 어쨋든 운영환경 배포 시나 제품 패키징 시에 test 패키지 이하를 따로 발췌해내야 하는 불편함이 있다.   | 
| 선호도 | 보통  | 



### #4. 소스 폴더는 다르게, 패키지는 동일, 컴파일된 클래스는 각각 다른 곳으로 (추천)
|    |           | 
|----------|-------------|
| 장점 |  대상 클래스와 테스트 클래스를 동일한 패키지로 선언할 수 있다. 접근 범위(scope) default나 protected로 선언된 메소드도 테스트 케이스로 작성할 수 있다. 컴파일된 대상 클래스와 테스트 클래스의 위치가 최상위 폴더부터 다르게 만들어지기 때문에, 서로 섞일 염려가 없다. 배포시에도 분리가 쉽고 빠르게 패키징이 가능하다.    | 
| 단점 |    환경 구성 방법이 다소 의존적이다.    | 
| 선호도 | 매우 높음. 대부분의 사람에게 가장 권하는 스타일이다.   | 



### #5. 테스트를 프로젝트로 분리
|    |           | 
|----------|-------------|
| 장점 |  제품 코드와 테스트 케이스 코드의 외부 라이브러리 의존관계를 명확히 분리해낸다. 즉, 테스트를 위해 사용되는 라이브러리는 어떤 것이고, 순수하게 제품 코드를 위한 라이브러리는 어떠한 것인지 구분할 수 있다. 이클립스 IDE 프로젝트 차원에서 분리되므로, 제품 코드와 테스트 코드를 프로젝트 레벨로 개별적 배포가 용의하다.    | 
| 단점 |    환경 구성 방법이 다소 의존적이다. Ant 스크립트 등의 외부 툴을 함께 쓸 경우, 클래스패스 관련해서 스크립트 작성이 번거로워진다.   | 
| 선호도 | 프로젝트 라이브러리에 대해 상세화된 전권행사(Detailed Full Control)를 원하는 개발자에게 추천.   | 



### #6. 메이븐(Maven) 스타일
|    |           | 
|----------|-------------|
| 장점 |  제품 코드에 필요한 리소스와 테스트에 사용하는 리소스를 분리해서 관리하기에 편하다. 메이븐 방식으로 구성된 프로젝트를 접할 때 어색하지 않다.    | 
| 단점 |  이런 형태의 구조를 처음 접하는 유저의 경우 익숙해질 때까지는 구조가 불편하게 느껴지거나 환경에 적응하는데 시간이 걸릴 수 있다. 프로젝트 팀 전체가 이 구조로 가기 위해서는 교육과 의지가 동반되어야 한다.    | 
| 선호도 | 보통. Maven 사용자에겐 거의 회피할 수 없는 구조이다.    | 



## 테스트 메소드 작성 방식

### #1. 테스트 대상 메소드와 이름을 1:1로 일치
|    |           | 
|----------|-------------|
| 테스트 대상 코드  |  public int getBalance() {...}    | 
| 테스트 코드 |     @Test public void testGetBalance(){...}    | 
| 장점 | 테스트 메소드의 숫자가 적어져서 보기가 편하고, 대상이 되는 클래스의 메소드와 1:1로 연관지어 생각할 수 있다.     | 
| 단점 | 추가적인 테스트 케이스가 하나의 테스트 메소드 내에 전부 존재하게 만들 경우, 메소드 내의 초반 테스트 단정문이 실패하면, 뒤쪽 테스트 케이스들은 실행되지 않는다. 이럴 경우 성공하는 케이스와 실패하는 케이스가 중간중간 섞여 있을 수도 있지만, 구별해낼 수 없다.     | 


### #2. 테스트 대상 메소드의 이름 뒤에 추가적인 정보를 기재(추천)
|    |           | 
|----------|-------------|
| 테스트 대상 코드  |  public void withdraw(int money){...}    | 
| 테스트 코드 |     @Test public void testWithdraw_마이너스통장인출(){...}    | 
| 장점 | 더 다양한 케이스별로 성공/실패를 알 수 있다. 케이스마다 독립적적으로 수행할 수 있어 오류의 가능성이 좀 더 줄어든다.      | 
| 단점 | 테스트 케이스만큼 메소드를 만들기 때문에 메소드 숫자가 많아진다. 테스트 메소드 이름을 짓는 데 상당한 요령이 필요하다. 케이스마다 리소스 초기와(setup) 작업이 필요하다.     | 



### #3. 테스트 시나리오에 집중
|    |           | 
|----------|-------------|
| 테스트 대상 코드  | 특정한 메소드를 대상으로 하기보다는 테스트 시나리오가 대상이 된다.     | 
| 테스트 코드 |     @Test public void VIP고객이_인출할때_수수료계산(){....}    | 
| 장점 | 테스트 케이스를 시나리오에 따라 체계적으로 작성할 수 있다. 테스트 케이스를 하나의 업무 단위 테스트 단위처럼 문서화 할 수 있다.       | 
| 단점 | 테스트 대상 클래스의 단위 메소드 구현 시에 사용하기에는 다소 무리가 따른다.      | 


## 테스트 케이스 작성 접근 방식

### 무엇을 테스트 케이스로 작성할 것인가?

초창기에는 어떤 것을 테스트로 삼을 건지, 바로 찾아내기가 쉽지 않을 때가 많다. 이럴 때 사용할 수 있는 흔한 접근 방식이 몇가지 있다. 우선, 시나리오식 접근 방법을 들 수 있다.

- 해피데이 시나리오, 정상적인 흐름일 때 동작해야 하는 결과값을 선정해 높는 방식.
- 블루데이 시나리오, 발생할 수 있는 예와나 에러 상황에 대한 결과값을 적는  방식.
- 삼각측량법, '두 숫자 곱하기(a,b)' 메소드는 a*b와 같은지 비교해보고, a를 b번 더한 것과도 같은지 비교해보는 방식.
- 에지 케이스(Edge Case), 경계조건 찾아내기는 양수, 음수, 0, 아주 큰값, 소수점 등을 떠올리면 된다.

다음과 같은 질문을 해보자. 

🔹 결과가 옳은가?

🔹 모든 경계조건이 옳은가?

🔹 역(inverse)관계를 확인할 수 있는가? 

🔹 다른 수단을 사용해서 결과를 교차확인할 수 있는가?

🔹 에러 조건을 강제로 만들어 낼 수 있는가? 

🔹 성능이 한도 내에 있는가? 

 

## TDD의 한계

- 동시성 문제

    테스트 자체를 무결하게 유지하기가 매우 어렵다. 상식적으로 파악하기 어려운 불규칙한 문제가 적지않게 발생하기 때문이다. 

- 접근제한자(private/protected 메소드)

    private으로 되어 있는 메소드는 일반적인 방법으로 테스트가 불가능하다. 그러나 그에 앞서, private으로 되어 있어서 접근이 어려운 메소드의 테스트 필요성 자체에 대한 논의가 먼저 필요할 것 같다. 현재는 'public으로 되어 있는 메소드만 테스트해도 무방하다'라는 경향이 대세인것으로 보인다. 

- GUI

    GUI는 심미적인 부분이 강하고, 사용자의 동작에 다라 화면이 많은 영향을 받기 때문에 테스트하기가 어렵거나 복잡해진다. 뷰에 해당하는 영역이 TDD를 적용하기 곤란한 GUI 영역이다. 

- 의존성 모듈 테스트(target = A but A → B)

    테스트의 대상이 되는 A가 기타 메소드나 클래스를 참조하고 있을 경우, 그리고 해당 참조 부분에 대한 접근이 쉽지 않을 경우에는 B는 어떻게 할 것인가?